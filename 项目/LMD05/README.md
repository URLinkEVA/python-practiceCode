# Message-Digest Algorithm
一种简单信息摘要算法 

## 算法设计
和其他摘要算法类似，算法输入任意长度的bit流，输出由字符0-9、a-z、A-Z、#、&组成的字符串，长度可自定义为8、16、24、32，构造Lmd05类时可传入需要的长度 * 3，如24、48等。

## 变换模块
算法通过四个语句对四个设定初始值的magic number进行重复操作变换，不断累计变换的同时，可以达到类似输出随机数的效果。 

四个变换语句分别为：
```
a = ((b & c) | ((~b) & d)) ^ a ^ seed
b = (c | a & ~d) ^ b ^ seed
c = a ^ b ^ c ^ d ^ seed
d = (b ^ ~d ^ (~a | c)) ^ seed 
```
变换语句需要保证在多次循环变换后四个magic number每位的0或1数量大体相等且平均分布。
语句中a、b、c、d为四个magic number，seed为外部传入的数。
需要变换时，除seed外还需指定传入seed的二进制长度input_bits和输出数需要的二进制长度output_bits，同时保存类属性cond决定下一次变换时使用的语句序号。

在每次变换前，将32除以input_bits向上取整后的数循环向左填充seed（python中还需要将32位以外的位做置0操作），得到seed填充后的32位数t_full，
以避免seed过小导致变换后的位不能平均分布。随后将t_full异或cond，加1后对3取余，得到0-3的整数，即执行并返回cond对应的变换语句。

变换后，同样需要对变换后的输出与(1 << output_bits ) – 1按位与运算，保证输出为指定位数的数。

## 填充部分
输入的bit流需要进行填充、分块后参与运算，由于算法支持自定义输出长度，则分块的大小需要按照输出长度调整，填充的个数也不相同。

填充时，首先计算需要填充的位数n，(块长度 – 数据长度 % 块长度) 即为要填充的位数n。随后循环填充n次，填充的数据将n作为初始值，每次循环时循环左移1位填充。此处的目的是尽可能打乱源数据，保证输出结果均匀分布。

## 运算部分
填充后，将数据按块大小分块，循环参与运算。

建立数组vector_list，长度为块大小的一半，填充变换模块seed为0、output_bits为8变换后的随机值作为初始值。

顺序遍历每个块内4bit长的数据，将块内index左移8位和数据做或运算，作为seed参数传入变换模块、output_bits为8、input_bits为16，vector_list中index除以2的值更新为原值异或变换后的结果。并将vector_list循环左移块内数据对应的数字。

每个块计算完成后，将变换模块四个随机值做异或计算，结果去二进制后8位，分别对vector_list每一位做异或运算。至此运算部分结束。

## 转字符&输出部分
算法将二进制6位数0-63对应64个字符，分别是0-9、a-z、A-Z和#、&两个符号。运算完成后的vector_list每3项数据，即3个二进制8位数对应2个二进制6位数，再转为字符类型。

以步长为3遍历vector_list，得到3个二进制8位数，记为i0、i1、i2，将i0第3和4位、i1前4位拼为6位二进制数，i0后4位、i0前2位拼为6位二进制数，
做异或运算得到一个6位的二进制数，对应一个字符；i2和i1后4位做相同的操作得到另一个6位二进制数。
遍历完成后得到vector_list长度除以3乘以2长度的字符串，即为最终结果。

## 执行效率
C++版本，100000个随机数字字符串执行10次平均耗时3.42秒，100000个随机数字字符串输出32位结果执行10次平均耗时10.44秒。

python版本，100000个随机数字字符串执行10次平均耗时21.48秒，100000个随机数字字符串输出32位结果执行10次平均耗时79.85秒。

作为对比，Python版md5算法执行同样100000个随机数字字符串10次平均耗时11.02秒。 
